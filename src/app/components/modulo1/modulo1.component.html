<div class="container mx-auto text-center mb-20 space-y-4 mt-6">

    <h2 class="text-xl box-decoration-clone
     bg-gradient-to-r from-blue-500 to-green-300 text-white px-2 font-serif box-border h-128 w-128 p-4 border-4 mt-6">modulo <br>1</h2>


    <h1 class="text-lg text-white font-serif">Arquitectura de software</h1>

    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">Arquitectura de software. La arquitectura de software es un conjunto de patrones que proporcionan un marco de referencia necesario para guiar la construcción de un software,permitiendo a los programadores, analistas y todo el conjunto de desarrolladores
            del software compartir una misma línea de trabajo y cubrir todos los objetivos y restricciones de la aplicación.Es considerada el nivel más alto en el diseño de la arquitectura de un sistema puesto que establecen la estructura,funcionamiento
            e interacción entre las partes del software.
        </p>
    </div>

    <h1 class="text-lg text-white font-serif">Componentes e interacciones</h1>

    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <h1 class="text-titulos text-white font-serif">Componentes</h1>
        <p class="text-base text-white font-serif text-left">La arquitectura de software se compone por: <br>

            <br> -clientes y servidores.
            <br> -bases de datos.
            <br> -filtros.
            <br> -niveles en sistemas jerárquico.
        </p>
        <br>
        <h1 class="text-titulos text-white font-serif">Interacciones</h1>
        <p class="text-base text-white font-serif text-left">Entre los componentes de la arquitectura de software existe un conjunto de interacciones entre las que sobresalen: <br>

            <br> -llamadas a procedimientos.
            <br> -comportamiento de variables.
            <br> -protocolos cliente servidor.
            <br> -transmición asíncrona de eventos.
        </p>
        <div class="inset-x-0 shadow-xl bg-white w-3/4 md:w-2/5 mx-auto mt-4 rounded-lg rounded-t-none">
            <img src="https://keepcoding.io/wp-content/uploads/2022/04/image-2.png" class="max-w-full h-auto" alt="..." />
        </div>
    </div>

    <h1 class="text-lg text-white font-serif">Características</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">La arquitectura de software forma la columna vertebral para construir un sistema de software,es en gran medida responsable de permitir o no ciertos atributos de calidad del sistema entre los que se destacan la confiabilidad y el rendimiento del
            software.Además es un modelo abstracto reutilizable que puede transferirse de un sistema a otro y que representa un medio de comunicación y discusión entre participantes del proyecto,permitiendo así la interacción e intercambio entre los desarrolladores
            con el objetivo final de establecer el intercambio de conocimientos y puntos de vista entre ellos.</p>
    </div>
    <h1 class="text-lg text-white font-serif">Historia de la arquitectura de software</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">Aunque el término “arquitectura de software”, tal y como lo concebimos ahora, aparece en 1992 con el trabajo de Perry y Wolf, sus antecedentes se remontan al menos hasta finales de la década de los sesenta. En 1968, Dijkstra habla de una estructuración
            correcta de los sistemas de software, aunque no la llama arquitectura como tal. Posteriormente, en 1969, P. I. Sharp, comentando las ideas de Dijkstra, ya usa el término arquitectura de software al mencionar que quizá luego se hable de “la
            escuela de arquitectura de software de Dijkstra”, y al mismo tiempo lamentar que la industria de ese tiempo preste muy poca atención a ésta.
            <br><br>Durante la década de los setentas el concepto de arquitectura deambuló por el aire sin una semántica clara y carente de una expresión pragmática. En esta misma década, el diseño estructurado dio pie a la independencia entre el diseño
            y la implementación. Los trabajos de Parnas sobre técnicas de modularización en decisiones de diseño y familias de programas, fueron, sin duda, aportaciones esenciales y permanentes.
            <br><br>Las decisiones “tempranas” de diseño, argüía Parnas, probablemente permanecerían invariantes en el desarrollo de la solución; estas ideas se convierten luego en lo que hoy se conocen como decisiones arquitectónicas.
            <br><br>Rompiendo esquemas y acaparando la atención en la década de los ochentas, aparece el paradigma de la orientación a objetos. En esta década aparecen dos trabajos importantes de Mary Shaw, que retoman las abstracciones de alto nivel:
            “Técnicas de abstracción en lenguajes modernos de programación” y “Los sistemas de gran escala requieren de abstracciones de alto nivel”.
            <br><br>Hacia finales de los ochenta y principios de los noventa, comienza a gestarse de manera más clara la idea de que las aplicaciones tienen una morfología, una estructura. El trabajo de Perry y Wolf de 1992 es el punto de partida para
            lo que hoy conocemos como arquitectura de software. Por un lado, son los primeros que proponen un modelo para la arquitectura de software; este modelo contempla a la arquitectura formada por tres componentes: elementos, forma y razón. Los
            elementos pueden ser de procesamiento, datos o conexión; la forma se define de acuerdo a las propiedades de, y a las relaciones entre los elementos; la razón se contempla en términos de restricciones del sistema, que se derivan de los requerimientos
            del sistema.
            <br><br>Perry y Wolf profetizaron que: “la década de los noventas, creemos, será la década de la arquitectura de software”, lo cual se convirtió en realidad. A lo largo de esa década, salieron a la luz varios trabajos con propuestas relevantes,
            entre ellas, la programación basada en componentes, el surgimiento de los patrones y estilos, el modelo de 4+1 vistas, y lenguajes de descripción de arquitecturas (ADLs) entre otras.
            <br><br>En la segunda mitad de los noventa aparecen los primeros libros de texto dedicados a la arquitectura de software. El año 2000 cierra esta década con dos trabajos clave: el modelo REST propuesto en la tesis de Roy Fielding que pone
            la atención en Internet y los modelos orientados a servicios; y el trabajo de la IEEE, que genera una versión definitiva de la recomendación IEEE std 1471-2000.
            <br><br>También en este año se abren nuevas perspectivas para la arquitectura de software, aparecen las estrategias orientadas a líneas de productos y se procura insertar la arquitectura de software dentro del ciclo de vida, obligando a redefinir
            las metodologías referentes a él en términos de arquitectura.
            <br><br>Actualmente hay una cierta efervescencia alrededor de desarrollos centrados en arquitectura, métodos de análisis y diseño de arquitecturas (dentro del ciclo de vida), análisis de arquitecturas de software basados en escenarios, modelos
            de evaluación de arquitecturas de software y modelos orientados por la arquitectura entre algunos otros tópicos.
            <br><br>Definiciones, Definiciones, Definiciones... Martin Fowler, en su artículo “Who needs an Architect?”, deja salir su cinismo (según él mismo lo expresa), y como primer intento, define arquitectura como: “una palabra que utilizamos cuando
            queremos hablar del diseño y queremos que se escuche como algo importante”. Encontrar una definición aceptada universalmente no es tarea fácil, de hecho no existe. Por el contrario, se puede literalmente nadar en un mar de definiciones. Lo
            que existe es un consenso intuitivo de qué es arquitectura de software. Este consenso intuitivo involucra generalmente un diagrama: círculos o cuadros unidos por alguna línea, alguna identificación de estos elementos y poca cosa más. La interpretación
            recae en forma importante en quién la ve (y la puede entender) o la diseña, y seguramente fuera de este círculo lo que provoca es simplemente confusión.
            <br><br>La construcción de una definición textual de arquitectura de software se basa y se ha basado en la mayoría de los casos en interpretar estos diagramas y darles de alguna manera coherencia. Así podemos encontrar que las definiciones
            iniciales se refieren a componentes o elementos relacionados entre sí (estructura) primordialmente. Luego se le ha agregado que también las propiedades de los elementos son parte de la arquitectura; otros más se decantan por el conjunto de
            decisiones de diseño (sin marcar cómo podrían mostrarse en un diagrama), y algunos más aterrizan la definición como aquellos aspectos que son inmutables en un sistema de software o difíciles de cambiar. Una definición a la que se recurre más
            es la presentada por Bass, et al.: “Una arquitectura de software de un programa o un sistema computacional es la estructura del sistema, la cual comprende elementos de software, las propiedades externamente visibles de esos elementos, y las
            relaciones entre ellos”.
            <br><br>El principal problema con las definiciones que se han dado (cientos) es que aunque tratan de ubicar una idea clara de lo que es arquitectura de software, terminan por ajustarse al entorno en cuestión y sólo establecen para ese momento
            un consenso. No es difícil encontrar que cada trabajo sobre arquitecturas, sobre todo los académicos, inician por adaptar o formular lo que para su contexto se entenderá por arquitectura de software.
            <br><br>Evidentemente esta debilidad alrededor de una definición formalmente aceptada no ha impedido que existan trabajos tanto prácticos como académicos, y por lo tanto, un desarrollo sustancial en la disciplina. Quizá el lector tenga la
            sensación de que entonces no hay problema. En parte sí, antes de la postulación de la ley de la gravedad las manzanas seguían cayendo igual; pero una vez formulada, el panorama se vio muy diferente.
            <br><br>A Futuro... Trabajo Básico por Hacer Le propongo al lector un par de ejercicios. Examine cualquier diagrama que se ostente como representación de una arquitectura, luego intente tomar la definición mencionada anteriormente o cualquier
            otra y busque emparejarlas; seguramente tendrá algunas dificultades.
            <br><br>Otro ejercicio puede ser pasear un poco por el Proceso Unificado de Racional (RUP) que pregona ser un proceso orientado por casos de uso y centrado en la arquitectura; de nuevo, ajustar la definición de arquitectura de software empelada
            en ese momento (por el autor que escribe o diserta sobre RUP) con algunos de los artefactos que se proponen en este proceso no es una tarea sencilla... igual, encontrará dificultades. Para empezar, existe un cierto sentimiento dentro de la
            academia que estimula a pensar que los diagramas propuestos por UML no son precisamente una representación arquitectónica.
            <br><br>Como se puede apreciar, no todo es un lecho de rosas. La bala de plata aún está en construcción (aunque sería iluso pensar que algún día se terminará de construir) y la arquitectura de software es tan sólo un elemento importante.</p>
    </div>

    <br>
    <br>
    <br>






    <h1 class="text-lg text-white font-serif">Lenguajes de Descripción Arquitectónica</h1>
    <br>
    <br>
    <br>
    <h1 class="text-lg mb-2 text-white font-serif">¿Que es un lenguaje de descripcion arquitectonico?</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">ADL . Lenguaje descriptivo de modelado arquitectónico de software que se focaliza en la estructura de alto nivel de la aplicación antes que en los detalles de implementación de sus módulos concretos. Su abreviatura es ADL.</p>
    </div>
    <h1 class="text-lg mb-2 text-white font-serif">Surgimiento</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">Los ADL se remontan a los lenguajes de interconexión de módulos (MIL) de la década de 1970, pero se han comenzado a desarrollar con su denominación actual a partir de la década de 1990, poco después de fundada la propia arquitectura de software
            como especialidad profesional. Estos lenguajes surgen por la necesidad de satisfacer los requerimientos descriptivos de alto nivel de abstracción que las herramientas basadas en objeto en general y UML en particular no cumplen satisfactoriamente.</p>
    </div>
    <h1 class="text-lg mb-2 text-white font-serif">Estilos de arquitectura de software</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">Un «estilo» de arquitectura es un conjunto de decisiones de diseño arquitectural que son aplicables en un contexto de desarrollo específico, restringen las decisiones de diseño de un sistema a ese contexto y plantean como objetivo ciertas cualidades
            para el sistema resultante. Establecen un vocabulario común, donde se dan nombres a los componentes y conectores así como a los elementos de datos Establecen un conjunto de reglas de configuración, como la topología del sistema Definen una
            semántica para las reglas de composición de los elementos Posibilitan el análisis de los sistemas construidos sobre el estilo Algunos ejemplos de estilos arquitecturales: <br><br> -Influenciados por los Lenguajes de Programación <br> -Programación
            estructurada Orientado a Objetos <br> -Capas Máquinas Virtuales Cliente Servidor n-Tier <br> -Peer-to-Peer <br> -Flujo de Datos Batch Pipes and Filters <br> -Memoria Compartida Blackboard Rule Based <br> -Interprete <br> -Invocación Implícita
            Event-based Publisher-suscriber
        </p>
    </div>
    <h1 class="text-lg mb-2 text-white font-serif">Patrones de Arquitecturas de Software</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">Un Patrón de Arquitectura de Software es un conjunto de decisiones de diseño que se pueden aplicar a un problema de diseño recurrente y que pueden parametrizarse para diferentes contextos donde ese problema de diseño aparece. <br>

            <br> -Estructuras
            <br> -Capas
            <br> -Pipes and Filters
            <br> -Blackboard
            <br> -Sistemas Interactivos
            <br> -Model-View-Controller
            <br> -Presentation-Abstraction-Communication
            <br> -Sistemas Distribuidos
            <br> -Broker
            <br> -Trader
            <br> -Sistemas Adaptables
            <br> -Reflection
            <br> -Microkernel
        </p>
    </div>
    <h1 class="text-lg mb-2 text-white font-serif">Modalidades y tendencias</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">En la década de 1990 se establece definitivamente la AS como un dominio todavía hoyseparado de manera confusa de ese marco global que es la ingeniería y de esa prácticapuntual que es el diseño. Aunque no hay un discurso explícito y autoconsciente
            sobreescuelas de AS, ni se ha publicado un estudio reconocido y sistemático que analice lasparticularidades de cada una, en la actualidad se pueden distinguir a grandes rasgos unasseis corrientes. Algunas distinciones están implícitas por
            ejemplo en, pero labibliografía sobre corrientes y alternativas prácticamente no existe y la que sigue habráde ser por un tiempo una de las pocas propuestas contemporáneas sobre el particular.Ahora bien, articular una taxonomía de estrategias
            no admite una solución simple ydeterminista. En distintos momentos de su trayectoria, algunos practicantes de la AS semueven ocasionalmente de una táctica a otra, o evolucionan de un punto de vista másgenérico a otro más particular, o realizan
            diferentes trabajos operando en marcosdistintos. Además, con la excepción del “gran debate metodológico” entre métodos 26pesados y ligeros, las discusiones entre las distintas posturas rara vez se hanmanifestado como choques frontales entre
            ideologías irreconciliables, por lo que amenudo hay que leer entre líneas para darse cuenta que una afirmación cualquiera es unacrítica a otra manera de ver las cosas, o trasunta una toma definida de posición. Fuera dela metodología, el único
            factor reconocible de discordia ha sido, hasta la fecha, lapreminencia de UML y el diseño orientado a objetos. Todo lo demás parece ser más omenos negociable.</p>
    </div>
    <h1 class="text-lg mb-2 text-white font-serif">Campos de la Arquitectura de Software</h1>
    <div class="box-border h-128 w-128 p-4 border-4 mt-6">
        <p class="text-base text-white font-serif text-left">La AS es hoy en día un conjunto inmenso y heterogéneo de áreas de investigación teóricay de formulación práctica, por lo que conviene aunque más no sea enumerar algunos desus campos y sus focos. Una semblanza semejante (de la que aquí se proporciona
            sólo unrudimento) dudosamente debería ser estática. La AS comenzó siendo una abstraccióndescriptiva puntual que en los primeros años no investigó de manera sistemática ni lasrelaciones que la vinculaban con los requerimientos previos, ni los
            pasos metodológicos adar luego para comenzar a componer el diseño. Pero esa sincronicidad estructuralista nopudo sostenerse. Por el contrario, daría la impresión que, a medida que pasa el tiempo, laAS tiende a redefinir todos y cada uno de
            los aspectos de la disciplina madre, la 24ingeniería de software, sólo que a un mayor nivel de abstracción y agregando una nuevadimensión reflexiva en lo que concierne a la fundamentación formal del proceso. <br><br>Hay unas pocas caracterizaciones
            (y mucha actividad de copiado y pegado) en torno delas áreas que componen el territorio. David Garlan y Dewayne Perry, en su introducciónal volumen de abril de 1995 de IEEE Transactions on Software Engineering dedicado a laAS, en el cual se
            delinean las áreas de investigación más promisorias, enumeran las siguientes:
            <br><br> •Lenguajes de descripción de arquitecturas
            <br> •Fundamentos formales de la AS (bases matemáticas, caracterizaciones formales depropiedades extra-funcionales tales como mantenibilidad, teorías de la interconexión,etcétera).
            <br> •Técnicas de análisis arquitectónicas
            <br> •Métodos de desarrollo basados en arquitectura
            <br> •Recuperación y reutilización de arquitectura
            <br> •Codificación y guía arquitectónica
            <br> •Herramientas y ambientes de diseño arquitectónico
            <br> •Estudios de casos <br><br> Fundamental en la concepción de Clements y Northrop es el criterio dereusabilidad como uno de los aspectos que más hacen por justificar la disciplina misma.Según estos autores, el estudio actual de la AS puede
            ser visto como un esfuerzo ex postfacto para proporcionar un almacén estructurado de este tipo de información reutilizablede diseño de alto nivel propio de una familia (en el sentido de Parnas). De tal manera, lasdecisiones de alto nivel inherentes
            a cada miembro de una familia de programas nonecesitan ser re-inventadas, re-validadas y re-descriptas. Un razonamiento arquitectónicoes además un argumento sobre las cuestiones estructurales de un sistema. Se diríatambién que el concepto
            de estilo es la encarnación principal del principio de reusabilidaden el plano arquitectónico. <br><br> Paul Clements define cinco temas fundamentales en torno de los cuales seagrupa la disciplina:
            <br><br> •Diseño o selección de la arquitectura: Cómo crear o seleccionar una arquitectura enbase de requerimientos funcionales, de performance o de calidad.
            <br> •Representación de la arquitectura: Cómo comunicar una arquitectura. Esteproblema se ha manifestado como el problema de la representación de arquitecturasutilizando recursos lingüísticos, pero el problema también incluye la selección
            delconjunto de información a ser comunicada.
            <br> •Evaluación y análisis de la arquitectura: Cómo analizar una arquitectura parapredecir cualidades del sistema en que se manifiesta. Un problema semejante es cómocomparar y escoger entre diversas arquitecturas en competencia.
            <br> •Desarrollo y evolución basados en arquitectura: Cómo construir y mantener unsistema dada una representación de la cual se cree que es la arquitectura que resolveráel problema correspondiente.
            <br> •Recuperación de la arquitectura: Cómo hacer que un sistema legacy evolucionecuando los cambios afectan su estructura; para los sistemas de los que se carezca dedocumentación confiable, esto involucra primero una “arqueología arquitectónica”que
            extraiga su arquitectura.
            <br><br> Mary Shaw considera que en el 2001 los campos más promisorios de la ASsiguen teniendo que ver con el tratamiento sistemático de los estilos, el desarrollo delenguajes de descripción arquitectónica, la formulación de metodologías y
            (ahora) eltrabajo con patrones de diseño. Se requieren todavía modelos precisos que permitanrazonar sobre las propiedades de una arquitectura y verificar su consistencia ycompletitud, así como la automatización del proceso de análisis, diseño
            y síntesis.Sugiere que debe aprenderse una lección a partir de la experiencia de la ingeniería desoftware, la cual no obstante haberse desenvuelto durante treinta años no ha logradoplasmar un conjunto de paradigmas de investigación comparable
            al de otras áreas de lasciencias de la computación. Estima que la AS se encuentra ya en su fase de desarrollo yextensión, pero que tanto las ideas como las herramientas distan de estar maduras. <br><br> Un campo que no figura en estas listas
            pero sobre el cual se está trabajando intensamentees en el de la coordinación de los ADLs que sobrevivan con UML 2.0 por un lado y conXML por el otro. Ningún lenguaje de descripción arquitectónica en el futuro próximo(excepto los que tengan
            un nicho técnico muy particular) será viable si no satisface esosdos requisitos. <br><br> Los ejercicios que pueden hacerse para precisar los campos de la AS son incontables.Ahora que la AS se ha abismado en el desarrollo de metodologías,
            hace falta, porejemplo, establecer con más claridad en qué difieren sus elaboraciones en torno deldiseño, del análisis de requerimientos o de justificación económica de las llevadas a cabopor la ingeniería de software. Asimismo, se está esperando
            todavía una lista sistemática yexhaustiva que describa los dominios de incumbencia de la disciplina, así como unexamen del riesgo de duplicación de esfuerzos entre campos disciplinarios malcomunicados, una situación que a primera vista parecería
            contradictoria con el principiode reusabilidad.

        </p>
    </div>

    <iframe width="560" height="315" src="https://www.youtube.com/embed/watch?v=jycewGAOWoI&t=4s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="mx-auto"></iframe>

    <button routerLink="home" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-full">
      home
    </button>









</div>
